(load "ch1.scm")

;; Exercise 1.1

10
12
8
3
4
19
#f
4
16
6
16

;; Exercise 1.2

(/ (+ 5
      4
      (- 2 (- 3 (+ 6 4/5))))
   (* 3
      (- 6 2)
      (- 2 7)))

;; Exercise 1.3

(define (sum-squares-two-larger a b c)
  (cond ((and (>= b a) (>= c a))
	 (+ (* b b) (* c c)))
	((and (>= a b) (>= c b))
	 (+ (* a a) (* c c)))
	((and (>= a c) (>= b c))
	 (+ (* a a) (* b b)))))

;; Exercise 1.4

;; If b is greater than 0, then produce the sum of a and b; otherwise, produce the subtraction of b from a.

;; Exercise 1.5

;; An interpreter using applicative-order evaluation runs forever, while an interpreter using normal-order evaluation produces 0.
;; With applicative-order evaluation, the two operands, namely 0 and (p) are evaluated before test is applied to the arguments. When (p) is evaluated, the interpreter runs forever according to the definition of the procedure p.
;; With normal-order evaluation, the operands are only evaluated when they are needed. Since the first operand x is evaluated to 0, the special form if evaluates the consequent expression, which returns 0 directly, without evaluating the second operand. Thus, the interpreter returns 0.

;; Exercise 1.6

;; The new procedure sqrt-iter runs forever.
;; Note that the issue of new-if is that both of the consequent and alternative expressions are evaluated before new-if is applied to them. This, however, means that no matter whether guess is good enough for x, another call to sqrt-iter will be made. This implies that any call to sqrt-iter does not terminate.

;; Exercise 1.7

;; For very small numbers, e.g., numbers less than 0.001, the threshold of a "reasonably acceptable" guess will be much smaller than 0.001. For instance, if x is 1e-10, then the square root of x is 1e-5, but the current sqrt function would accept, e.g., 0, as an approximation to the actual square root because the absolute difference between the square of 0 and 1e-10 is 1e-10, which is smaller than our threshold 0.001. The interpreter outputs 0.03125000106562499 as the result of (sqrt 1e-10), whereas the square root of 0.03125000106562499 is 9.76562566601563e-4, much greater than 1e-10.
;; For very large numbers, on the other hand, it is hard for guesses to be "good enough". Because arithmetic operations in real computers are always performed with limited precision, there will always be an error of the actual output from the desired one. For very large numbers, this error is augmented; therefore, guesses are very unlikely to fall under the "good enough" range. For instance, the interpreter does not terminate for (sqrt 1e50).

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (< (/ (abs (- (improve guess x) guess))
	guess)
     0.001))

(define (improve guess x)
  (average guess (/ x guess)))

(define (abs x)
  (if (< x 0)
      (- x)
      x))

(define (average x y)
  (/ (+ x y) 2))

(define (sqrt x)
  (sqrt-iter 1.0 x))

;; The new approach works better for small and large numbers.

;; Exercise 1.8

(define (cube-root-iter guess x)
  (if (good-enough? guess x)
      guess
      (cube-root-iter (improve guess x) x)))

(define (improve guess x)
  (/ (+ (/ x (* guess guess))
	(* 2 guess))
     3))

(define (cube-root x)
  (cube-root-iter 1.0 x))

;; Exercise 1.9

;; Process generated by the first procedure
;; (+ 4 5)
;; (inc (+ 3 5))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (+ 1 5))))
;; (inc (inc (inc (inc (+ 0 5)))))
;; (inc (inc (inc (inc 5))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9

;; Process generated by the second procedure
;; (+ 4 5)
;; (+ 3 6)
;; (+ 2 7)
;; (+ 1 8)
;; (+ 0 9)
;; 9

;; The first process is recursive, while the second process is iterative.

;; Exercise 1.10

;; (A 1 10)
;; (A 0 (A 1 9))
;; (A 0 (A 0 (A 1 8)))
;; (A 0 (A 0 (A 0 (A 1 7))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
;; (A 0 (A 0 (A 0 (A 0 64))))
;; (A 0 (A 0 (A 0 128)))
;; (A 0 (A 0 256))
;; (A 0 512)
;; 1024

;; (A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 4))
;; (A 1 16)
;; 65536

;; (A 3 3)
;; (A 2 (A 3 2))
;; (A 2 (A 2 (A 3 1)))
;; (A 2 (A 2 2))
;; (A 2 4)
;; 65536

;; (f n) computes 2n
;; (g n) computes 2^n
;; (h n) computes 2^(2^(2^...)), with n 2's

;; Exercise 1.11

(define (f-recursive n)
  (if (< n 3)
      n
      (+ (f-recursive (- n 1))
	 (* 2 (f-recursive (- n 2)))
	 (* 3 (f-recursive (- n 3))))))

(define (f-iterative n)
  (define (iter a b c count)
    (if (= count 0)
	c
	(iter (+ a
		 (* 2 b)
		 (* 3 c))
	      a
	      b
	      (- count 1))))
  (iter 2 1 0 n))

;; Exercise 1.12

(define (pascal-triangle row col)
  (if (or (= col 1) (= row col))
      1
      (+ (pascal-triangle (- row 1) (- col 1))
	 (pascal-triangle (- row 1) col))))

;; Exercise 1.13

;; We will first prove by induction on n that Fib(n) = (phi^n - psi^n) / sqrt(5).
;; Base case:
;; 1) n = 0. Fib(0) = 0. (phi^0 - psi^0) / sqrt(5) = (1 - 1) / sqrt(5) = 0.
;; 2) n = 1. Fib(1) = 1. (phi^1 - psi^1) / sqrt(5) = ((1 + sqrt(5)) / 2 - (1 - sqrt(5)) / 2) / sqrt(5) = 2 sqrt(5) / 2 / sqrt(5) = 1.
;; Induction step:
;; Let n be a positive integer > 1. Assume that Fib(k) = (phi^k - psi^k) / sqrt(5) for all k < n, k is a nonnegative integer. By the definition of Fibonacci numbers,
;; Fib(n) = Fib(n - 1) + Fib(n - 2)
;;        = (phi^(n - 1) - psi^(n - 1)) / sqrt(5) + (phi^(n - 2) - psi^(n - 2)) / sqrt(5)
;;        = (phi^(n - 1) - psi^(n - 1) + phi^(n - 2) - psi^(n - 2)) / sqrt(5)
;;        = (phi^(n - 2) * (phi + 1) - psi^(n - 2) * (psi + 1)) / sqrt(5)
;; It is easy to verify that phi + 1 = phi^2 and psi + 1 = psi^2. Thus,
;; Fib(n) = (phi^(n - 2) * phi^2 - psi^(n - 2) * psi^2) / sqrt(5)
;;        = (phi^n - psi^n) / sqrt(5)
;; Hence, Fib(n) = (phi^n - psi^n) / sqrt(5) follows by induction.
;; We will then show that Fib(n) is the closest integer to phi^n / sqrt(5). From the definition of Fibonacci numbers, Fibonacci numbers are integers. We have
;; |Fib(n) - phi^n| = |psi^n / sqrt(5)| = |psi^n| / sqrt(5)
;; Note that |psi = (1 - sqrt(5)) / 2| < 1, so |psi^n| = |psi|^n < 1. Thus,
;; |Fib(n) - phi^n| < 1 / sqrt(5) < 1 / 2
;; That is, phi^n - 1 / 2 < Fib(n) < phi^n + 1 / 2. Note that there is at most one integer in the range (phi^n - 1 / 2, phi^n + 1 / 2). Thus, Fib(n) is the closest integer to phi^n / sqrt(5).
;; This completes the proof.

;; Exercise 1.14

;;                                                                cc 11 5
;;                                                               /       \
;;                                                           cc 11 4      cc -39 5
;;                                                          /       \
;;                                                      cc 11 3      cc -14 4
;;                                                     /       \
;;                                              cc 11 2         cc 1 3
;;                                             /       \       /      \
;;                                      cc 11 1   cc 6 2      cc 1 2   cc -9 3
;;                                     /  \        /    \          / \
;;                              cc 11 0  cc 10 1  cc 6 1        cc 1 2        cc 1 1  cc -4 2
;;                                      /\       /      \         /    \       /     \
;;                              cc 10 0  cc 9 1  cc 6 0  cc 5 1  cc 1 1 cc -4 2 cc 1 0  cc 0 1
;;                                       /\              /\        /   \
;;                              cc 9 0   cc 8 1  cc 5 0  cc 4 1  cc 1 0  cc 0 1
;;                                       /\              /\
;;                              cc 8 0   cc 7 1  cc 4 0  cc 3 1
;;                                       /\              /\
;;                              cc 7 0   cc 6 1  cc 3 0  cc 2 1
;;                                       /\              /\
;;                              cc 6 0   cc 5 1  cc 2 0  cc 1 1
;;                                       /\              /\
;;                              cc 5 0   cc 4 1  cc 1 0  cc 0 1
;;                                       /\
;;                              cc 4 0   cc 3 1
;;                                       /\
;;                              cc 3 0   cc 2 1
;;                                       /\
;;                              cc 2 0   cc 1 1
;;                                       /\
;;                              cc 1 0   cc 0 1

;; Let n be the amount to be changed. Let k be the largest kind of coins. Let T(k, n) be the number of steps used by the process. Let c(k) be the first denomination of k kinds of coins. Then we have
;; T(k, n) = T(k - 1, n) + T(k, n - c(k))
;; T(0, n) = 1
;; In particular,
;; T(1, n) = T(0, n) + T(1, n - 1) = 1 + T(1, n - 1)
;; Thus, T(1, n) = n = Theta(n)
;; Furthermore,
;; T(2, n) = T(1, n) + T(2, n - 5) = Theta(n) + T(2, n - 5) = n / 5 * Theta(n) = Theta(n^2).
;; Repeating this process, we can see that
;; T(k, n) = Theta(n^k)
;; Hence, the order of growth of the number of steps used by the process is Theta(n^5).

;; Let S(k, n) be the space used by the process. Then we have
;; S(k, n) = max(S(k - 1, n), S(k, n - c(k))) + 1
;; S(0, n) = 1
;; Note that each time either k is reduced by 1, or n is reduced by c(k). Thus, the order of growth of the space used by the process is Theta(n + k). Since, furthermore, k is a constant, then the order of growth of the space is Theta(n).

;; Exercise 1.15

;; a. The number of times that the procedure p is applied when (sine 12.15) is evaluated is equal to the number of times that 12.15 is repeatedly divided by 3 until the result is <= 0.1. Note that
;; 12.15 / 3 = 4.05
;; 4.05 / 3 = 1.35
;; 1.35 / 3 = 0.45
;; 0.45 / 3 = 0.15
;; 0.15 / 3 = 0.05 < 0.1
;; Thus, the procedure p is applied five times when (sine 12.15) is evaluated.

;; b. Let T(a) be the number of steps and the space used by the process when (sine a) is evaluated. Then we have
;; T(a) = T(a / 3) + 1, a >  0.1
;; T(a) = 1,            a <= 0.1
;; Thus, we have
;; T(a) = Theta(log_3 (10a)) = Theta(log a).
;; Hence, the order of growth in space and number of steps used by the process generated by the sine procedure is Theta(log a) when (sine a) is evaluated.

;; Exercise 1.16

(define (fast-expt-iterative b n)
  (define (iter b n a)
    (cond ((= n 0) a)
	  ((even? n)
	   (iter (* b b)
		 (/ n 2)
		 a))
	  (else
	   (iter b
		 (- n 1)
		 (* a b)))))
  (iter b n 1))

(define (even? n)
  (= (remainder n 2) 0))

;; Exercise 1.17

(define (fast-mult a b)
  (cond ((= b 0) 0)
	((even? b)
	 (* 2
	    (fast-mult a (/ b 2))))
	(else
	 (+ a
	    (fast-mult a (- b 1))))))

;; Exercise 1.18

(define (fast-mult-iterative a b)
  (define (iter a b c)
    (cond ((= b 0) c)
	  ((even? b)
	   (iter (* a 2)
		 (/ b 2)
		 c))
	  (else
	   (iter a
		 (- b 1)
		 (+ a c)))))
  (iter a b 0))

;; Exercise 1.19

;; After applying T_pq once, we get new values of a and b simultaneously
;; a' <- bq + aq + ap
;; b' <- bp + aq
;; After applying T_pq once more, we get
;; a'' <- b'q + a'q + a'p = (bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p = b(2pq + q^2) + a(2pq + q^2) + a(p^2 + q^2)
;; b'' <- b'p + a'q = (bp + aq)p + (bq + aq + ap)q = b(p^2 + q^2) + a(2pq + q^2)
;; Therefore, we have
;; p' = p^2 + q^2
;; q' = 2pq + q^2

(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
	((even? count)
	 (fib-iter a
		   b
		   (+ (* p p) (* q q))
		   (+ (* 2 p q) (* q q))
		   (/ count 2)))
	(else (fib-iter (+ (* b q) (* a q) (* a p))
			(+ (* b p) (* a q))
			p
			q
			(- count 1)))))

;; Exercise 1.20

;; In the normal-order evaluation
;; (gcd 206 40)
;; (if (= 40 0)
;;     206
;;     (gcd 40 (remainder 206 40)))
;; (gcd 40 (remainder 206 40))
;; (if (= (remainder 206 40) 0)
;;     40
;;     (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
;; (if (= 6 0)
;;     40
;;     (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
;; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
;; (if (= (remainder 40 (remainder 206 40)) 0)
;;     (remainder 206 40)
;;     (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
;; (if (= 4 0)
;;     (remainder 206 40)
;;     (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
;; (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;; (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0)
;;     (remainder 40 (remainder 206 40))
;;     (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;          (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
;; (if (= 2 0)
;;     (remainder 40 (remainder 206 40))
;;     (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;          (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))
;; (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;      (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
;; (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0)
;;     (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;     (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;;          (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;                     (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
;; (if (= 0 0)
;;     (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;     (gcd (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;;          (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;;                     (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))))
;; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
;; 2
;; Hence, 18 remainder operations are performed in the normal-order evaluationof (gcd 206 40).

;; In the applicative-order evaluation
;; (gcd 206 40)
;; (gcd 40 (remainder 206 40))
;; (gcd 40 6)
;; (gcd 6 (remainder 40 6))
;; (gcd 6 4)
;; (gcd 4 (remainder 6 4))
;; (gcd 4 2)
;; (gcd 2 (remainder 4 2))
;; (gcd 2 0)
;; 2
;; Hence, 4 remainder operations are performed in the applicative-order evaluation of (gcd 206 40).

;; Exercise 1.21

;; The smallest divisor of each of 199, 1999 and 19999 is 199, 1999 and 7, respectively.

;; Exercise 1.22

(define (search-for-primes l r)
  (if (<= l r)
      (begin (timed-prime-test l)
	     (search-for-primes (+ l 1) r))))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (runtime)
  (/ (time-nanosecond (current-time)) 1000))

;; The three smallest primes larger than 1000 are 1009, 1013 and 1019. The time needed to test each prime is 1 microseconds, 2 microseconds and 1 microseconds, respectively.
;; The three smallest primes larger than 10000 are 10007, 10009 and 10037. The time needed to test each prime is 4 microseconds, 4 microseconds, 4 microseconds, respectively.
;; The three smallest primes larger than 100000 are 100003, 100019 and 100043. The time needed to test each prime is 12 microseconds, 12 microseconds and 12 microseconds, respectively.
;; The three smallest primes larger than 1000000 are 1000003, 1000033 and 1000037. The time needed to test each prime is 37 microseconds, 37 microseconds, 37 microseconds, respectively.
;; We can see from the timing data above that testing for primes around 10000 takes approximately 3 times as long as testing for primes around 1000 on average, so the data bears the Theta(sqrt(n)) prediction out. The data for 100000 and 1000000 also support the Theta(sqrt(n)) prediction. The result is compatible with the notion that programs on the machine run in time proportional to the number of steps required for the computation.

;; Exercise 1.23

(define (smallest-divisor n)
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (next test-divisor)))))
  (define (next divisor)
    (if (= divisor 2)
	3
	(+ divisor 2)))
  (find-divisor n 2))

;; The time needed to test each prime around 1000 is 2 microseconds, 1 microseconds and 1 microseconds, respectively.
;; The time needed to test each prime around 10000 is 4 microseconds, 3 microseconds and 4 microseconds, respectively.
;; The time needed to test each prime around 100000 is 7 microseconds, 7 microseconds and 7 microseconds, respectively.
;; The time needed to test each prime around 1000000 is 18 microseconds, 19 microseconds and 19 microseconds, respectively.

;; From the data recorded above, the observed ratios of the speeds of the two algorithms are 1, 12/11, 12/7 and 111/56, respectively. As the number being tested gets larger, the observed ratio is approaching the expected ratio 2. The fact that it is different from 2 can be explained by the reason that there is time spent on system overheads such as procedure calls.

;; Exercise 1.24

(define (start-prime-test n start-time)
  (if (fast-prime? n 10)
      (report-prime (- (runtime) start-time))))

;; The time needed to test each prime around 1000 is 18 microseconds, 17 microseconds and 17 microseconds, respectively.
;; The time needed to test each prime around 10000 is 28 microseconds, 27 microseconds and 28 microseconds, respectively.
;; The time needed to test each prime around 100000 is 33 microseconds, 34 microseconds and 34 microseconds, respectively.
;; The time needed to test each prime around 1000000 is 42 microseconds, 39 microseconds and 39 microseconds, respectively.

;; The time needed to test primes near 1000000 is expected to be twice as long as the time needed to test primes near 1000, because log(1000000) / log(1000) = log_1000 1000000 = 2.
;; From the recorded timing data, the actual time needed to test primes near 1000000 is approximately 30/13 = 2.3 times as long as the actual time needed to test primes near 1000.
;; The actual ratio is very similar to the expected ratio. Nevertheless, the small discrepancy between the expected ratio and the actual ratio can be explained by system overheads such as procedure calls.

;; Exercise 1.25

;; Alyssa is not correct. Note that the length of the decimal expansion of b^(2n) is approximately twice as long as the length of the decimal expansion of b^n. Therefore, if we take the remainder after computing the exponential, we must consider the time needed on arithmetic operations in terms of decimal expansion lengths. Hence, the time complexity required for Alyssa's expmod is O(log(n) * log(b^n)) = O(n log(n)), so this procedure does not serve as well as the previous fast prime tester.

;; Exercise 1.26

;; Note that when exp is even, Louis' expmod function recursively calls expmod on (/ exp 2) twice. Let T(n) be the running time of the expmod function when the argument exp is equal to n. Then we have
;; T(n) = 2T(ceil(n / 2)) + 1
;; Thus, we have T(n) = Theta(n), whereas the original expmod function takes Theta(log(n)) time.

;; Exercise 1.27

(define (test-carmichael n)
  (define (iter a)
    (cond ((>= a n) #t)
	  ((test-fermat-little a) (iter (+ a 1)))
	  (else #f)))
  (define (test-fermat-little a)
    (= (expmod a n n) a))
  (iter 1))

;; Exercise 1.28

(define (miller-rabin n times)
  (define (expmod base exp mod)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (check-square (expmod base (/ exp 2) mod)
			 mod))
	  (else
	   (remainder (* base
			 (expmod base (- exp 1) mod))
		      mod))))
  (define (check-square x n)
    (if (and (not (= x 1))
	     (not (= x (- n 1)))
	     (= (remainder (square x) n) 1))
	0
	(remainder (square x) n)))
  (cond ((= times 0) #t)
	((= (expmod (+ 1 (random (- n 1))) (- n 1) n) 1)
	 (miller-rabin n (- times 1)))
	(else #f)))

;; Exercise 1.29

(define (simpsons-rule f a b n)
  (define (term k)
    (* (cond ((or (= k 0) (= k n)) 1)
	     ((even? k) 2)
	     (else 4))
       (f (+ a (* k (/ (- b a) n))))))
  (* (sum term 0 inc n)
     (/ (/ (- b a) n) 3)))

;; Exercise 1.30

(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (+ a 1)
	      (+ (term a) result))))
  (iter a 0))

;; Exercise 1.31

;; a.

(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
	 (product term (next a) next b))))

(define (factorial n)
  (product identity 1 inc n))

(define (pi-product n)
  (define (numerator-term k)
    (if (even? k)
        (+ k 2)
	(+ k 1)))
  (define (denominator-term k)
    (if (even? k)
	(+ k 1)
	(+ k 2)))
  (* 4
     (/ (product numerator-term 1 inc n)
	(product denominator-term 1 inc n))))

;; b.

(define (product term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a)
	      (* (term a) result))))
  (iter a 1))

;; Exercise 1.32

;; a.

(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
		(accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))

;; b.

(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
	result
	(iter (next a)
	      (combiner (term a) result))))
  (iter a null-value))

;; Exercise 1.33

(define (filtered-accumulate filterer? combiner null-value term a next b)
  (cond ((> a b) null-value)
	((filterer? a)
	 (combiner (term a)
		   (filtered-accumulate filterer? combiner null-value term (next a) next b)))
	(else (filtered-accumulate filterer? combiner null-value term (next a) next b))))

(define (sum-square-primes a b)
  (filtered-accumulate prime? + 0 identity a inc b))

(define (product-relatively-prime n)
  (define (relatively-prime? a)
    (= (gcd a n) 1))
  (filtered-accumulate relatively-prime? * 1 identity 1 inc (- n 1)))

;; Exercise 1.34

;; Using the substitution semantics, (f f) returns the same value as (f 2). Using the substitution semantics again, we will instead evaluate (2 2). Since 2 is a number but not a procedure, it cannot be applied to 2, so an error is raised.

;; Exercise 1.35

;; Note that 1 + 1 / phi = 1 + 1 / ((1 + sqrt(5)) / 2) = 1 + 2 / (1 + sqrt(5)) = (3 + sqrt(5)) / (1 + sqrt(5)) = (3 + sqrt(5))(1 - sqrt(5)) / (1 + sqrt(5))(1 - sqrt(5)) = (-2 - 2 sqrt(5)) / (1 - 5) = (-2 - 2 sqrt(5)) / (-4) = (1 + sqrt(5)) / 2 = phi. Hence, phi is a fixed point of the transformation x -> 1 + 1 / x.

(define phi
  (fixed-point (lambda (x) (+ 1 (/ 1 x)))
	       1.0))

;; Exercise 1.36

(define (fixed-point-print f first-guess)
  (define tolerance 0.00001)
  (define (closed-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (closed-enough? guess next)
	  next
	  (try next))))
  (try first-guess))

(define (fixed-point-print-damping f first-guess)
  (define tolerance 0.00001)
  (define (closed-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (average guess (f guess))))
      (if (closed-enough? guess next)
	  next
	  (try next))))
  (try first-guess))

;; From the outputs of the two versions of fixed-point, we can see that the version with damping requires much less steps than the version without damping.

;; Exercise 1.37

;; a.

(define (cont-frac n d k)
  (define (recurse n d i)
    (if (= i k)
	(/ (n k) (d i))
	(/ (n i)
	   (+ (d i)
	      (recurse n d (+ i 1))))))
  (recurse n d 1))

;; One must make k equal to 11 in order to get an approximation that is accurate to 4 decimal places.

;; b.

(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
	result
	(iter (- i 1)
	      (/ (n i)
		 (+ (d i) result)))))
  (iter k 0))

;; Exercise 1.38

(define e
  (+ 2 (cont-frac (lambda (i) 1.0)
		  (lambda (i)
		    (let ((mod-3 (remainder i 3)))
		      (cond ((= mod-3 0) 1.0)
			    ((= mod-3 1) 1.0)
			    ((= mod-3 2) (* 2 (/ (+ i 1) 3))))))
		  1000)))

;; Exercise 1.39

(define (tan-cf x k)
  (cont-frac (lambda (i)
	       (if (= i 1)
		   x
		   (- (* x x))))
	     (lambda (i) (- (* 2 i) 1))
	     k))

;; Exercise 1.40

(define (cubic a b c)
  (lambda (x)
    (+ (* x x x)
       (* a x x)
       (* b x)
       c)))

;; Exercise 1.41

(define (double f)
  (lambda (x)
    (f (f x))))

;; The value returned by (((double (double double)) inc) 5) is 21.

;; Exercise 1.42

(define (compose f g)
  (lambda (x)
    (f (g x))))

;; Exercise 1.43

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

;; Exercise 1.44

(define (smooth f)
  (define dx 0.001)
  (lambda (x)
    (/ (+ (f (- x dx))
	  (f x)
	  (f (+ x dx)))
       3)))

(define (n-fold-smooth f n)
  ((repeated smooth n) f))

;; Exercise 1.45

;; floor(log(n)) average damps are required to compute the n-th roots as a fixed-point search based upon repeated average damping of y -> x / y^(n - 1).

(define (nth-root x n)
  (fixed-point ((repeated average-damp (floor (log n 2)))
		(lambda (y) (/ x (expt y (- n 1)))))
	       1.0))

;; Exercise 1.46

(define (iterative-improve good-enough? improve)
  (define (try guess)
    (if (good-enough? guess)
	guess
	(try (improve guess))))
  try)

(define (sqrt x)
  (define tolerance 0.00001)
  ((iterative-improve (lambda (guess)
			(< (abs (- (square guess) x)) tolerance))
		      (lambda (guess)
			(average guess (/ x guess))))
   1.0))

(define (fixed-point f first-guess)
  (define tolerance 0.00001)
  ((iterative-improve (lambda (guess)
			(< (abs (- guess (f guess))) tolerance))
		      f)
   first-guess))
